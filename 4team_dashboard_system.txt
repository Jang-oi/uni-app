# 구독4팀 대시보드 시스템 기획서

## 1. 프로젝트 개요

### 1.1 목적
구독그룹 구독4팀에서 사용하는 Desktop App 시스템
- 휴가/일정 공유
- 업무 조회 및 알림
- HyperV 사용 현황 공유

### 1.2 시스템 구성

```
┌─────────────────────────────────────────────────────────────────────┐
│                         시스템 전체 구조                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ┌───────────────────────────────────────┐                         │
│   │      내 PC - Electron Master App      │                         │
│   │                                        │                         │
│   │   • 크롤링 담당 (BrowserWindow)        │                         │
│   │   • 스케줄링 (node-cron)               │                         │
│   │   • 내 계정으로 로그인 유지             │                         │
│   │   • 크롤링 결과 → 서버 API 전송        │                         │
│   │                                        │                         │
│   │   + 일반 사용자 기능도 포함            │                         │
│   └───────────────────┬───────────────────┘                         │
│                       │                                              │
│                       │ POST /api/vacations                          │
│                       │ POST /api/tasks                              │
│                       ▼                                              │
│   ┌───────────────────────────────────────┐                         │
│   │      공용 PC - Express Server         │                         │
│   │                                        │                         │
│   │   • REST API (단순 CRUD)              │                         │
│   │   • SQLite + Prisma                   │                         │
│   │   • Socket.io 브로드캐스트             │                         │
│   │                                        │                         │
│   │   ※ 크롤링 없음, 로그인 정보 없음      │                         │
│   └───────────────────┬───────────────────┘                         │
│                       │                                              │
│          ┌────────────┼────────────┬────────────┐                   │
│          │            │            │            │                   │
│          ▼            ▼            ▼            ▼                   │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐              │
│   │ 팀원 A   │ │ 팀원 B   │ │ 팀원 C   │ │ 팀원 D   │              │
│   │ Electron │ │ Electron │ │ Electron │ │ Electron │              │
│   │          │ │          │ │          │ │          │              │
│   │ • 조회   │ │ • 조회   │ │ • 조회   │ │ • 조회   │              │
│   │ • 알림   │ │ • 알림   │ │ • 알림   │ │ • 알림   │              │
│   │ • HyperV │ │ • HyperV │ │ • HyperV │ │ • HyperV │              │
│   └──────────┘ └──────────┘ └──────────┘ └──────────┘              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.3 기술 스택

| 구분 | 기술 | 비고 |
|------|------|------|
| **Master App** | Electron-Vite | 크롤링 + 일반기능 |
| **Server** | Express.js | 최대한 심플하게 |
| **Database** | SQLite + Prisma | 경량 |
| **실시간** | Socket.io | 양방향 통신 |
| **스케줄링** | node-cron | Electron에서 실행 |

---

## 2. 앱 구분

### 2.1 Master App (내 PC 전용)

일반 사용자 기능 + 크롤링/스케줄링 기능

```typescript
// 앱 시작 시 모드 구분
const isMaster = process.env.APP_MODE === 'master';

if (isMaster) {
  // 크롤링 스케줄러 시작
  startCrawlerScheduler();
}
```

### 2.2 Client App (팀원들)

조회/알림/HyperV 기능만

```
동일한 코드베이스, 환경변수로 모드 구분
APP_MODE=client (기본값)
APP_MODE=master (내 PC만)
```

---

## 3. Electron Master App 상세

### 3.1 프로젝트 구조

```
electron-team-dashboard/
├── electron/
│   ├── main/
│   │   ├── index.ts                 # 메인 프로세스 진입점
│   │   ├── window.ts                # 윈도우 관리
│   │   │
│   │   ├── crawler/                 # 크롤링 모듈 (Master 전용)
│   │   │   ├── index.ts             # 크롤러 매니저
│   │   │   ├── scheduler.ts         # node-cron 스케줄러
│   │   │   ├── vacation.crawler.ts  # 휴가 크롤링
│   │   │   ├── task.crawler.ts      # 업무 크롤링
│   │   │   └── browser.ts           # BrowserWindow 크롤링 유틸
│   │   │
│   │   ├── hyperv/                  # HyperV 모듈 (모든 앱)
│   │   │   ├── index.ts
│   │   │   └── monitor.ts           # PowerShell 실행
│   │   │
│   │   ├── api/                     # 서버 API 통신
│   │   │   └── client.ts
│   │   │
│   │   ├── socket/                  # Socket.io 클라이언트
│   │   │   └── client.ts
│   │   │
│   │   └── notification/            # Windows 알림
│   │       └── index.ts
│   │
│   └── preload/
│       └── index.ts
│
├── src/                             # React (Renderer)
│   ├── App.tsx
│   ├── main.tsx
│   │
│   ├── components/
│   │   ├── Calendar/                # 휴가/일정 캘린더
│   │   ├── TaskList/                # 업무 목록
│   │   ├── HypervStatus/            # HyperV 현황
│   │   └── common/
│   │
│   ├── pages/
│   │   ├── Dashboard.tsx
│   │   ├── Calendar.tsx
│   │   ├── Tasks.tsx
│   │   └── Hyperv.tsx
│   │
│   ├── hooks/
│   │   ├── useSocket.ts
│   │   ├── useVacations.ts
│   │   ├── useTasks.ts
│   │   └── useHyperv.ts
│   │
│   ├── stores/                      # 상태 관리 (zustand 또는 jotai)
│   │   ├── vacation.store.ts
│   │   ├── task.store.ts
│   │   ├── hyperv.store.ts
│   │   └── user.store.ts
│   │
│   ├── services/
│   │   └── api.ts                   # API 호출
│   │
│   └── types/
│       └── index.ts
│
├── electron-store/                  # 로컬 저장소 (개인 일정 등)
│
├── .env
├── .env.example
├── package.json
├── electron-builder.json
├── vite.config.ts
└── tsconfig.json
```

### 3.2 환경 설정

**.env.example**
```env
# 앱 모드
APP_MODE=client  # client | master

# 서버 설정
SERVER_URL=http://192.168.x.x:3000

# Master 전용 - 크롤링 대상 사이트
VACATION_SITE_URL=https://휴가사이트.company.com
TASK_SITE_URL=https://업무사이트.company.com

# Master 전용 - 팀원 목록 (업무 크롤링용)
TEAM_MEMBERS=홍길동,김철수,이영희,박민수,최지원,정다희
```

---

## 4. 크롤링 모듈 상세 (Master 전용)

### 4.1 크롤링 방식

**BrowserWindow를 이용한 실제 브라우저 크롤링**

```typescript
// browser.ts
import { BrowserWindow } from 'electron';

export class CrawlerBrowser {
  private window: BrowserWindow | null = null;

  async init() {
    this.window = new BrowserWindow({
      width: 1200,
      height: 800,
      show: false,  // 숨김 모드 (디버깅 시 true)
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
      }
    });
  }

  async navigateTo(url: string): Promise<void> {
    await this.window!.loadURL(url);
    await this.waitForLoad();
  }

  async executeScript<T>(script: string): Promise<T> {
    return await this.window!.webContents.executeJavaScript(script);
  }

  async waitForSelector(selector: string, timeout = 10000): Promise<void> {
    const script = `
      new Promise((resolve, reject) => {
        const start = Date.now();
        const check = () => {
          if (document.querySelector('${selector}')) {
            resolve(true);
          } else if (Date.now() - start > ${timeout}) {
            reject(new Error('Timeout waiting for ${selector}'));
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    `;
    await this.executeScript(script);
  }

  // 쿠키/세션은 Electron이 자동 관리
  // 한 번 로그인하면 유지됨
}
```

### 4.2 스케줄러

```typescript
// scheduler.ts
import cron from 'node-cron';
import { VacationCrawler } from './vacation.crawler';
import { TaskCrawler } from './task.crawler';

export class CrawlerScheduler {
  private vacationCrawler: VacationCrawler;
  private taskCrawler: TaskCrawler;

  constructor() {
    this.vacationCrawler = new VacationCrawler();
    this.taskCrawler = new TaskCrawler();
  }

  start() {
    // 휴가 크롤링: 09시, 12시, 18시
    cron.schedule('0 9,12,18 * * *', async () => {
      console.log('[Scheduler] 휴가 크롤링 시작');
      await this.vacationCrawler.crawl();
    });

    // 업무 크롤링: 매 1분
    cron.schedule('* * * * *', async () => {
      console.log('[Scheduler] 업무 크롤링 시작');
      await this.taskCrawler.crawl();
    });

    // 앱 시작 시 즉시 1회 실행
    this.runInitialCrawl();
  }

  private async runInitialCrawl() {
    await this.vacationCrawler.crawl();
    await this.taskCrawler.crawl();
  }
}
```

### 4.3 휴가 크롤러

```typescript
// vacation.crawler.ts
import { CrawlerBrowser } from './browser';
import { apiClient } from '../api/client';

export class VacationCrawler {
  private browser: CrawlerBrowser;

  constructor() {
    this.browser = new CrawlerBrowser();
  }

  async crawl() {
    try {
      await this.browser.init();
      
      // 1. 휴가 사이트 접속
      await this.browser.navigateTo(process.env.VACATION_SITE_URL!);
      
      // 2. 로그인 체크 (세션 만료 시 로그인 페이지로 리다이렉트됨)
      const isLoggedIn = await this.checkLogin();
      if (!isLoggedIn) {
        // 로그인 필요 알림 (수동 로그인 유도)
        this.notifyLoginRequired();
        return;
      }
      
      // 3. 휴가 목록 페이지 이동
      await this.browser.navigateTo(`${process.env.VACATION_SITE_URL}/list`);
      
      // 4. 데이터 파싱
      const vacations = await this.parseVacations();
      
      // 5. 서버로 전송
      await apiClient.post('/api/vacations/sync', { vacations });
      
      console.log(`[VacationCrawler] ${vacations.length}건 동기화 완료`);
      
    } catch (error) {
      console.error('[VacationCrawler] 크롤링 실패:', error);
    }
  }

  private async checkLogin(): Promise<boolean> {
    // 로그인 상태 확인 로직 (사이트별로 다름)
    const script = `
      // 예: 로그인 버튼이 없으면 로그인 상태
      !document.querySelector('.login-btn')
    `;
    return await this.browser.executeScript<boolean>(script);
  }

  private async parseVacations(): Promise<Vacation[]> {
    const script = `
      // 실제 사이트 구조에 맞게 수정 필요
      Array.from(document.querySelectorAll('.vacation-item')).map(el => ({
        employeeName: el.querySelector('.name')?.textContent?.trim(),
        startDate: el.querySelector('.start-date')?.textContent?.trim(),
        endDate: el.querySelector('.end-date')?.textContent?.trim(),
        type: el.querySelector('.type')?.textContent?.trim(),
      }));
    `;
    return await this.browser.executeScript<Vacation[]>(script);
  }

  private notifyLoginRequired() {
    // 메인 윈도우에 알림 전송
    // "휴가 사이트 로그인이 필요합니다" 팝업
  }
}
```

### 4.4 업무 크롤러 (멀티탭)

```typescript
// task.crawler.ts
import { BrowserWindow } from 'electron';
import { apiClient } from '../api/client';

export class TaskCrawler {
  private teamMembers: string[];

  constructor() {
    this.teamMembers = (process.env.TEAM_MEMBERS || '').split(',');
  }

  async crawl() {
    try {
      // 멀티 윈도우로 병렬 크롤링
      const windows = await this.createWindows();
      
      // 로그인 체크 (첫 번째 윈도우로)
      const isLoggedIn = await this.checkLogin(windows[0]);
      if (!isLoggedIn) {
        this.notifyLoginRequired();
        this.closeWindows(windows);
        return;
      }
      
      // 병렬로 크롤링 실행
      const results = await Promise.all([
        this.crawlTeamTasks(windows[0]),           // 팀 업무
        ...this.teamMembers.map((member, i) => 
          this.crawlMemberTasks(windows[i + 1], member)  // 개인별
        )
      ]);
      
      // 결과 병합 (중복 제거)
      const allTasks = this.mergeAndDeduplicate(results.flat());
      
      // 서버로 전송
      await apiClient.post('/api/tasks/sync', { tasks: allTasks });
      
      console.log(`[TaskCrawler] ${allTasks.length}건 동기화 완료`);
      
      this.closeWindows(windows);
      
    } catch (error) {
      console.error('[TaskCrawler] 크롤링 실패:', error);
    }
  }

  private async createWindows(): Promise<BrowserWindow[]> {
    const count = 1 + this.teamMembers.length; // 팀 + 개인별
    const windows: BrowserWindow[] = [];
    
    for (let i = 0; i < count; i++) {
      const win = new BrowserWindow({
        width: 1200,
        height: 800,
        show: false,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
          // 같은 세션 공유
          partition: 'persist:crawler'
        }
      });
      windows.push(win);
    }
    
    return windows;
  }

  private async crawlTeamTasks(window: BrowserWindow): Promise<Task[]> {
    // 팀 업무 페이지 크롤링
    await window.loadURL(`${process.env.TASK_SITE_URL}/team`);
    // ... 파싱 로직
    return [];
  }

  private async crawlMemberTasks(window: BrowserWindow, memberName: string): Promise<Task[]> {
    // 개인 업무 페이지 크롤링 (처리자 = memberName)
    const url = `${process.env.TASK_SITE_URL}/search?assignee=${encodeURIComponent(memberName)}`;
    await window.loadURL(url);
    // ... 파싱 로직
    return [];
  }

  private mergeAndDeduplicate(tasks: Task[]): Task[] {
    const map = new Map<string, Task>();
    for (const task of tasks) {
      map.set(task.taskId, task);
    }
    return Array.from(map.values());
  }

  private closeWindows(windows: BrowserWindow[]) {
    windows.forEach(w => w.close());
  }
}
```

### 4.5 수동 로그인 처리

```typescript
// 크롤링 중 로그인 필요 시
// 실제 브라우저 윈도우를 보여주고 사용자가 직접 로그인

export class LoginHandler {
  async showLoginWindow(site: 'vacation' | 'task'): Promise<boolean> {
    const url = site === 'vacation' 
      ? process.env.VACATION_SITE_URL 
      : process.env.TASK_SITE_URL;
    
    const loginWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      show: true,  // 보여줌
      title: `${site === 'vacation' ? '휴가' : '업무'} 사이트 로그인`,
      webPreferences: {
        partition: 'persist:crawler'  // 같은 세션 사용
      }
    });
    
    await loginWindow.loadURL(url!);
    
    // 로그인 완료 감지 (URL 변경 또는 특정 요소 등장)
    return new Promise((resolve) => {
      loginWindow.webContents.on('did-navigate', (_, newUrl) => {
        // 로그인 후 리다이렉트되는 URL 패턴 체크
        if (newUrl.includes('/dashboard') || newUrl.includes('/main')) {
          loginWindow.close();
          resolve(true);
        }
      });
      
      loginWindow.on('closed', () => {
        resolve(false);
      });
    });
  }
}
```

---

## 5. HyperV 모듈 (모든 앱 공통)

### 5.1 HyperV 모니터

```typescript
// hyperv/monitor.ts
import { exec } from 'child_process';
import { socketClient } from '../socket/client';
import os from 'os';

export class HypervMonitor {
  private hostname: string;
  private intervalId: NodeJS.Timeout | null = null;

  constructor() {
    this.hostname = os.hostname();
  }

  start() {
    // 5초마다 체크
    this.intervalId = setInterval(() => {
      this.checkAndReport();
    }, 5000);
    
    // 즉시 1회 실행
    this.checkAndReport();
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }

  private async checkAndReport() {
    const isConnected = await this.checkHypervConnection();
    const vmName = isConnected ? await this.getConnectedVmName() : null;
    
    socketClient.emit('hyperv:update', {
      hostname: this.hostname,
      vmName,
      isConnected,
      timestamp: new Date().toISOString()
    });
  }

  private checkHypervConnection(): Promise<boolean> {
    return new Promise((resolve) => {
      exec('netstat -ano | findstr 2179', (error, stdout) => {
        resolve(stdout.trim().length > 0);
      });
    });
  }

  private getConnectedVmName(): Promise<string | null> {
    return new Promise((resolve) => {
      const cmd = `powershell "Get-Process vmconnect -ErrorAction SilentlyContinue | ForEach-Object { $_.MainWindowTitle }"`;
      
      exec(cmd, (error, stdout) => {
        if (error || !stdout.trim()) {
          resolve(null);
          return;
        }
        
        // MainWindowTitle 형식: "VM이름 - Virtual Machine Connection"
        const title = stdout.trim();
        const vmName = title.split(' - ')[0];
        resolve(vmName || null);
      });
    });
  }
}
```

### 5.2 사용 요청 처리

```typescript
// hyperv/request.ts
import { socketClient } from '../socket/client';
import { Notification } from 'electron';
import os from 'os';

// 사용 요청 보내기
export function requestVmUsage(vmName: string, currentUserHostname: string) {
  socketClient.emit('hyperv:request', {
    fromHostname: os.hostname(),
    toHostname: currentUserHostname,
    vmName,
    timestamp: new Date().toISOString()
  });
}

// 사용 요청 수신 리스너
export function setupRequestListener() {
  socketClient.on('hyperv:request-received', (data) => {
    const { fromDisplayName, vmName } = data;
    
    new Notification({
      title: 'HyperV 사용 요청',
      body: `${fromDisplayName}님이 ${vmName} 사용을 요청했습니다.`,
      icon: './assets/icon.png'
    }).show();
  });
}
```

---

## 6. Socket.io 클라이언트

```typescript
// socket/client.ts
import { io, Socket } from 'socket.io-client';
import os from 'os';

class SocketClient {
  private socket: Socket | null = null;
  private serverUrl: string;

  constructor() {
    this.serverUrl = process.env.SERVER_URL || 'http://localhost:3000';
  }

  connect() {
    this.socket = io(this.serverUrl);
    
    this.socket.on('connect', () => {
      console.log('[Socket] 연결됨');
      
      // 접속 알림
      this.socket!.emit('client:connect', {
        hostname: os.hostname(),
      });
    });

    this.socket.on('disconnect', () => {
      console.log('[Socket] 연결 끊김');
    });

    // 이벤트 리스너 설정
    this.setupListeners();
  }

  private setupListeners() {
    // 휴가 데이터 업데이트
    this.socket!.on('vacation:updated', (data) => {
      // store 업데이트
      window.dispatchEvent(new CustomEvent('vacation:updated', { detail: data }));
    });

    // 업무 데이터 업데이트
    this.socket!.on('task:updated', (data) => {
      window.dispatchEvent(new CustomEvent('task:updated', { detail: data }));
    });

    // 업무 알림 (신규/상태변경)
    this.socket!.on('task:alert', (data) => {
      const { type, task, message } = data;
      
      new Notification({
        title: type === 'NEW' ? '신규 업무' : '업무 상태 변경',
        body: message,
      }).show();
    });

    // HyperV 전체 현황
    this.socket!.on('hyperv:status', (data) => {
      window.dispatchEvent(new CustomEvent('hyperv:status', { detail: data }));
    });

    // HyperV 사용 요청 수신
    this.socket!.on('hyperv:request-received', (data) => {
      new Notification({
        title: 'HyperV 사용 요청',
        body: `${data.fromDisplayName}님이 ${data.vmName} 사용을 요청했습니다.`,
      }).show();
    });
  }

  emit(event: string, data: any) {
    this.socket?.emit(event, data);
  }

  on(event: string, callback: (data: any) => void) {
    this.socket?.on(event, callback);
  }
}

export const socketClient = new SocketClient();
```

---

## 7. 메인 프로세스 진입점

```typescript
// electron/main/index.ts
import { app, BrowserWindow } from 'electron';
import { CrawlerScheduler } from './crawler/scheduler';
import { HypervMonitor } from './hyperv/monitor';
import { socketClient } from './socket/client';
import { setupRequestListener } from './hyperv/request';

const isMaster = process.env.APP_MODE === 'master';

let mainWindow: BrowserWindow | null = null;
let crawlerScheduler: CrawlerScheduler | null = null;
let hypervMonitor: HypervMonitor | null = null;

async function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // React 앱 로드
  if (process.env.NODE_ENV === 'development') {
    mainWindow.loadURL('http://localhost:5173');
  } else {
    mainWindow.loadFile('dist/index.html');
  }
}

app.whenReady().then(async () => {
  await createWindow();

  // Socket.io 연결
  socketClient.connect();
  
  // HyperV 요청 리스너 설정
  setupRequestListener();
  
  // HyperV 모니터 시작 (모든 앱)
  hypervMonitor = new HypervMonitor();
  hypervMonitor.start();

  // Master 모드일 때만 크롤러 시작
  if (isMaster) {
    console.log('[App] Master 모드로 실행 - 크롤러 시작');
    crawlerScheduler = new CrawlerScheduler();
    crawlerScheduler.start();
  }
});

app.on('window-all-closed', () => {
  hypervMonitor?.stop();
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
```

---

## 8. Express 서버 (별도 프로젝트)

서버는 최대한 심플하게 - CRUD + Socket.io 브로드캐스트만

### 8.1 프로젝트 구조

```
team-dashboard-server/
├── src/
│   ├── index.ts              # 진입점
│   ├── app.ts                # Express 앱
│   │
│   ├── routes/
│   │   ├── index.ts
│   │   ├── users.ts
│   │   ├── vacations.ts
│   │   ├── schedules.ts
│   │   ├── tasks.ts
│   │   └── hyperv.ts
│   │
│   ├── socket/
│   │   └── index.ts          # Socket.io 설정
│   │
│   └── prisma/
│       └── client.ts
│
├── prisma/
│   └── schema.prisma
│
├── .env
├── package.json
└── tsconfig.json
```

### 8.2 서버 코드 예시

```typescript
// src/index.ts
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import { PrismaClient } from '@prisma/client';

import userRoutes from './routes/users';
import vacationRoutes from './routes/vacations';
import scheduleRoutes from './routes/schedules';
import taskRoutes from './routes/tasks';
import hypervRoutes from './routes/hyperv';

const app = express();
const server = createServer(app);
const io = new Server(server, { cors: { origin: '*' } });
const prisma = new PrismaClient();

app.use(cors());
app.use(express.json());

// 라우트
app.use('/api/users', userRoutes);
app.use('/api/vacations', vacationRoutes(io));
app.use('/api/schedules', scheduleRoutes(io));
app.use('/api/tasks', taskRoutes(io, prisma));
app.use('/api/hyperv', hypervRoutes(io));

// Socket.io
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  socket.on('client:connect', async (data) => {
    const { hostname } = data;
    // 사용자 등록/조회
    await prisma.user.upsert({
      where: { hostname },
      update: { lastSeenAt: new Date() },
      create: { hostname, displayName: hostname }
    });
  });
  
  socket.on('hyperv:update', async (data) => {
    // DB 업데이트 후 전체 브로드캐스트
    // ...
    io.emit('hyperv:status', allStatus);
  });
  
  socket.on('hyperv:request', async (data) => {
    // 특정 사용자에게만 전송
    const targetSocket = findSocketByHostname(data.toHostname);
    targetSocket?.emit('hyperv:request-received', {
      fromDisplayName: data.fromDisplayName,
      vmName: data.vmName
    });
  });
});

server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### 8.3 업무 동기화 라우트 (변경 감지 포함)

```typescript
// src/routes/tasks.ts
import { Router } from 'express';
import { Server } from 'socket.io';
import { PrismaClient } from '@prisma/client';

export default function(io: Server, prisma: PrismaClient) {
  const router = Router();

  // Master App에서 크롤링 데이터 동기화
  router.post('/sync', async (req, res) => {
    const { tasks } = req.body;
    
    try {
      // 1. 기존 데이터 조회 (비교용)
      const oldTasks = await prisma.task.findMany();
      const oldTaskMap = new Map(oldTasks.map(t => [t.taskId, t]));
      
      // 2. 변경 감지
      const alerts: any[] = [];
      
      for (const task of tasks) {
        const oldTask = oldTaskMap.get(task.taskId);
        
        if (!oldTask) {
          // 신규 건
          alerts.push({
            type: 'NEW',
            task,
            message: `신규 업무: ${task.title}`
          });
        } else if (oldTask.status !== task.status) {
          // 상태 변경
          if (task.status === '고객사답변') {
            alerts.push({
              type: 'STATUS_CHANGED',
              task,
              previousStatus: oldTask.status,
              message: `고객사답변 등록: ${task.title}`
            });
          }
        }
      }
      
      // 3. DB 업데이트 (전체 교체)
      await prisma.$transaction([
        prisma.task.deleteMany(),
        prisma.task.createMany({ data: tasks })
      ]);
      
      // 4. 전체 데이터 브로드캐스트
      io.emit('task:updated', { tasks });
      
      // 5. 알림 발송 (해당 담당자에게만)
      for (const alert of alerts) {
        const targetSocket = findSocketByAssignee(alert.task.assignee);
        targetSocket?.emit('task:alert', alert);
      }
      
      res.json({ success: true, count: tasks.length, alerts: alerts.length });
      
    } catch (error) {
      res.status(500).json({ error: 'Sync failed' });
    }
  });

  // 조회
  router.get('/', async (req, res) => {
    const { assignee, status } = req.query;
    const where: any = {};
    if (assignee) where.assignee = assignee;
    if (status) where.status = status;
    
    const tasks = await prisma.task.findMany({ where });
    res.json(tasks);
  });

  return router;
}
```

---

## 9. 데이터베이스 스키마

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id          Int       @id @default(autoincrement())
  hostname    String    @unique
  displayName String
  searchName  String?   // 업무 검색용 이름
  lastSeenAt  DateTime  @default(now())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Vacation {
  id           Int      @id @default(autoincrement())
  employeeName String
  startDate    DateTime
  endDate      DateTime
  type         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([startDate, endDate])
}

model TeamSchedule {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  startDate   DateTime
  endDate     DateTime
  isAllDay    Boolean  @default(false)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([startDate, endDate])
}

model Task {
  id           Int       @id @default(autoincrement())
  taskId       String    @unique
  title        String
  assignee     String
  status       String
  customerName String?
  priority     String?
  createdDate  DateTime
  dueDate      DateTime?
  category     String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([assignee])
  @@index([status])
}

model HypervStatus {
  id           Int       @id @default(autoincrement())
  vmName       String    @unique
  vmHost       String?
  currentUser  String?
  userHostname String?
  isConnected  Boolean   @default(false)
  connectedAt  DateTime?
  updatedAt    DateTime  @updatedAt
}
```

---

## 10. 구현 우선순위

### Phase 1: Electron 기본 구조
1. electron-vite 프로젝트 초기화
2. 기본 윈도우 설정
3. 환경변수 설정 (APP_MODE)
4. 기본 React 페이지 구성

### Phase 2: 크롤러 모듈 (Master)
1. CrawlerBrowser 클래스
2. VacationCrawler 구현
3. TaskCrawler 구현 (멀티탭)
4. 스케줄러 연동
5. 수동 로그인 처리

### Phase 3: Express 서버
1. 프로젝트 초기화
2. Prisma + SQLite 설정
3. CRUD API 구현
4. Socket.io 설정

### Phase 4: 실시간 연동
1. Socket.io 클라이언트 (Electron)
2. 데이터 동기화 흐름
3. 알림 시스템

### Phase 5: HyperV
1. HyperV 모니터 구현
2. 사용 요청/알림 기능

### Phase 6: UI 구현
1. 캘린더 (휴가/일정)
2. 업무 목록
3. HyperV 현황

---

## 11. Claude Code 실행 가이드

```bash
# 1. Electron App 먼저 생성
claude "team-dashboard-spec.md 파일을 읽고 
Electron-Vite 프로젝트를 생성해줘.
Phase 1, 2부터 시작 - 기본 구조와 크롤러 모듈"

# 2. 서버 생성
claude "team-dashboard-spec.md 파일을 읽고
Express 서버 프로젝트를 생성해줘.
Phase 3 - 단순 CRUD + Socket.io"
```